자바 프로그래밍 정리 노트[2022.01.06] - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

📌 자바 프로그래밍 (Java Programming)
   ◾ 프로그래밍 (Programming) - 컴퓨터 프로그램 만드는 일
   ◾ 프로그래머 (Programmer) - 컴퓨터 프로그램 만드는 사람
   ◾ 프로그램 (Program) - 컴퓨터에게 일을 시키는 명령의 집합
   ◾ 컴파일 (Compile) - 컴퓨터가 이해할 수 있는 언어로 번역
   ◾ 컴파일러 (Compiler) - 컴파일 작업을 하는 프로그램

📌 자바 : 1991년 제임스 고슬링을 비롯한 선 마이크로시스템 연구원들이 처음 개발함

📌 자바 (Java) 장점
   1. 플랫폼에 영향 받지 않아 다양한 환경에서 사용가능 - '한 번 작성하면 어디서든 돌아간다'
   2. 객체 지향 언어로 유지보수 쉽고 확장성이 좋음
   3. 프로그램이 안정적이고 풍부한 기능을 제공하는 오픈 소스임 - 메모리를 효율적으로 관리

📌 자바 개발 환경
   ◾ 자바 가상 머신(JVM, Java Virtual Machine) : 자바 프로그램 실행 환경을 만들어 주는 SW
   ◾ 자바 실행 환경(JRE, Java Runtime Environment) : 현재 운영체제에서 자바를 구동할 수 있도록 함
   ◾ 자바 개발 도구(JDK, Java Development Kit) : 자바 가상 머신과 컴파일러, 디버거 등 도구들이 포함됨
   ◾ 통합 개발 환경(IDE) : 이클립스를 사용하며 코드 작성, 저장, 컴파일 및 디버깅을 도와줌

📌 변수 : 변하는 수, 저장할 공간의 이름, 컴퓨터 내부의 메모리 공간에 저장됨
   1. 변수 이름은 영문자나 숫자를 사용할 수 있고 특수 문자 중에 $, _만 사용가능
   2. 변수 이름은 숫자로 시작할 수 없음
   3. 자바에서 이미 사용중이 예약어는 사용할 수 없음 	ex) while, int, break 등

   ◾ 변수 이름은 소문자로 시작, 만약 여러 단어로 변수 이름을 만들 경우 중간에 다른 뜻의 단어가 등장할 때 첫 글자 대문자로 사용

📌 메모리 : 프로그램이 실행되는 작업 공
   ◾ 변수를 선언한다 : 선언한 변수 이름으로 어떤 위치에 있는 메모리를 얼마만큼의 크기로 사용하겠다고 한 것

📌 기본 자료형
   ◾ 정수 자료형 : 양수, 음수, 0 을 나타내는데 사용하는 자료형
	byte	(1바이트)
	short	(2바이트)
	int	(4바이트)
	long	(8바이트)
   ◾ 문자 자료형 : 문자를 변수에 대입하면 그 문자에 해당하는 정수 값(아스키 코드값)이 저장됨
	char	(2바이트)
   ◾ 실수 자료형 : 실수를 부동 소수점 방식으로 표현
	float	(4바이트)
	double	(8바이트)
   ◾ 논리 자료형 : 어떤 변수의 참, 거짓의 값을 나타냄
	boolean	(1바이트)

📌 자료형 없이 변수 선언
   ◾ 지역 변수 자료형 추론 : 자료형을 쓰지 않고도 변수를 사용, var를 사용

📌 상수(constant) : 항상 변하지 않는 값
   ◾ final 예약어

📌 리터럴(literal) : 프로그램에서 사용하는 모든 숫자, 문자, 논리값을 일컫는 말

📌 형 변환 : 각 변수의 자료형이 다를 때 자료형을 같게 바꾸는 것, 묵시적 형 변환 (자동 형 변환), 명시적 형 변환 (강제 형 변환)
   ◾ 형 변환 기본 원칙
      1) 바이트 크기가 작은 자료형에서 큰 자료형으로 형 변환은 자동으로 이루어짐
      2) 덜 정밀한 자료형에서 더 정밀한 자료형으로 형 변환은 자동으로 이루어짐

   ◾ 묵시적 형 변환 (자동 형 변환)
      1) 바이트 크기가 작은 자료형에서 큰 자료형으로 대입 - 자료 손실 없이 모두 저장됨
      2) 덜 정밀한 자료형에서 더 정밀한 자료형으로 대입 - 두 크기가 같은 변수임에더 불구하고 int형 보다 float형이 더 정밀하게 데이터 표현할 수 있어 실수형 float으로 자동 형 변환이 일어남 
      3) 연산 중에 자동 변환 - 바이트 크기가 작은 수에서 큰 수로, 덜 정밀한 수에서 더 정밀한 수로 자료형이 변환되는 경우에 자동 형 변환이 일어남
	   
   ◾ 명시적 형 변환 (강제 형 변환) : 프로그래머가 변환할 자료형을 명시적으로 써 주어야함.
      1) 바이트 크기가 큰 자료형에서 작은 자료형으로 대입 - byte형이 표현할 수 있는 범위를 넘는 경우 자료 손실이 발생
      2) 더 정밀한 자료형에서 덜 정밀한 자료형으로 대입 - 실수 자료형에서 정수 자료형으로 값이 대입되는 경우 실수의 소수점 이하 부분이 생략됨
      3) 연산 중에 형 변환 - 두 실수의 자료형이 다르지만 float형이 double형으로 변환되는 묵시적 형 변환이 일어나면서 두 수가 더해진 값이 나온 후 int형으로 명시적 형 변환이 일어남

📌 기본 연산자
   ◾ 연산자 (operator) - 연산에 사용하는 기호
   ◾ 항 (operand) - 연산에 사용하는 값
   ◾ 단항 연산자 : 항이 한 개인 연산자			ex) ++num
   ◾ 이항 연산자 : 항이 두 개인 사칙 연산		ex) num1 + num2;
   ◾ 삼항 연산자 : 항이 세 개인 연산자 (조건 연산자)	ex) (5>3) ? 1 : 0;

   ◾ 대입 연산자 : 변수에 값을 대입하는 연산자, 하나의 문장에 여러 연산자가 있을 때 모든 연산을 다 끝낸 후 마지막에 연산 결과를 변수에 대입
	왼쪽 변수 = 오른쪽 변수(또는 식)

   ◾ 부호 연산자 : 더하기(+), 빼기(-) 연산에 쓰는 이항 연산자이면서 부호를 나타내는 단항 연산자
	+	(변수나 상수 값을 양수로 만듬) 
	–	(변수나 상수 값을 음수로 만듬)

   ◾ 산술 연산자 : 사칙 연산에서 사용하는 연산자, 덧셈(+), 뺄셈(-), 곱셈(*), 나눗셈(/), 나머지(%)
	+
	–
	*
	/	(앞에 있는 항에서 뒤에 있는 항을 나누고 몫을 구함)
	%	(앞에 있는 항에서 뒤에 있는 항을 나누고 나머지를 구함)

   ◾ 증감•감소 연산자 : 단항 연산자로 연산자 앞이나 뒤에 사용하며 값을 1만큼 늘리거나 1만큼 줄임
	++ 연산자 : 항의 값에 1을 더함
	   val = ++num : 1 더한 후 val 변수에 대입 
	   val = num++ : val 변수에 num 대입한 후 1 더함
	-- 연산자 : 항의 값에 1을 뺌
	   val = --num : 1 뺀 후 val 변수에 대입 
	   val = num-- : val 변수에 num 대입한 후 1 뺌

   ◾ 관계 연산자 : 항이 두 개인 이항 연산자, 두 개의 항 중 어느 것이 더 큰지, 작은지, 같은지 등의 여부를 검사, 결과 값은 참(true) 또는 거짓(false)으로 반환
	>
	<
	>=
	<=
	==	(두 개 항의 값이 같으면 참, 아니면 거짓을 반환)
	!=	(두 개 항이 다르면 참, 아니면 거짓을 반환)

   ◾ 논리 연산자 : 두 명제가 모두 참이면 논리 곱은 참, 두명제 중 하나만 참이면 논리 합은 참, 참의 부정은 거짓, 거짓의 부정은 참, 관계 연산자가 논리 연산자보다 연산자 우선순위가 높음
	&& (논리 곱)	(두 항이 모두 참인 경우에만 결과 값이 참, 그렇지 않은 경우 거짓)
	|| (논리 합)	(두 항 중 하나의 항만 참이면 결과 값은 참, 두 항이 모두 거짓이면 결과 값은 거짓)
	! (부정)		(단항 연산자, 참인 경우는 거짓으로 바꾸고, 거짓인 경우 참으로 바꿈)

   ◾ 복합 대입 연산자 : 대입 연산자와 다른 연산자를 조합해 하나의 연산자처럼 사용하는 연산자, 우선순위가 가장낮은 연산자
	+= 	(두 항의 값을 더해서 왼쪽 항에 대입)
	-=	(왼쪽 항에서 오른쪽 항을 빼서 그 값을 왼쪽 항에 대입)
	*=	(두 항의 값을 곱해서 왼쪽 항에 대입)
	/=	(왼쪽 항을 오른쪽 항으로 나누어 그 몫을 왼쪽 항에 대입)
	%=	(왼쪽 항을 오른쪽 항으로 나누어 그 나머지를 왼쪽 항에 대입)
	<<=	(비트를 왼쪽으로 이동, 그 값을 왼쪽 항에 대입)
	>>=	(비트를 오른쪽으로 이동, 그 값을 왼쪽 항에 대입 (왼쪽 = 오른쪽, 부호 비트 동일))
	>>>=	(비트를 오른쪽으로 이동, 그 값을 왼쪽 항에 대입 (왼쪽에 채워지는 비트 값 0))
	&=	(두 항의 & 비트 연산 후 그 값을 왼쪽 항에 대입)
	|=	(두 항의 | 비트 연산 후 그 값을 왼쪽 항에 대입)
	^=	(두 항의 ^ 비트 연산 후 그 값을 왼쪽 항에 대입)

   ◾ 조건 연산자 : 연산에 필요한 항의 개수가 세 개, 삼항 연산자, 조건 연산은 주어진 조건식이 참인 경우와 거짓인 경우에 다른 결과 값이 나옴
	조건식? 결과1 : 결과2;

📌 비트 연산자 : 비트 단위로 연산이 이루어지는 연산자
   ◾ 비트 논리 연산자
	1) & (AND) 연산자	(두개의 비트 값이 모두 1인 경우에만 연산의 결과 값이 1이 됨)
	2) | (OR) 연산자	(비트 값이 하나라도 1이면 연산 결과 값이 1이 됨)
	3) ^ (XOR) 연산자	(같은 값이면 0, 다른 값이면 1이 됨)
	4) ~ (반전) 연산자	(비트 값을 (0→1, 1→0)으로 바꾸는 연산자)

   ◾ 비트 이동 연산자 ( = 시프트(shift) 연산자)
	1) << 연산자	(왼쪽으로 비트를 이동하는 연산자)
	2) >> 연산자	(오른쪽으로 비트를 이동하는 연산자)
	3) >>> 연산자	(오른쪽으로 비트를 이동하는 연산자)

   ◾ 연산자 우선순위
	1순위 : 일차식 	(), [] . 			연산방향 : →
	2순위 : 다항 	!, ++, --, +, -  		연산방향 : ←
	3순위 : 산술 	%, / 			연산방향 : →
	4순위 : 산술 	+, - 			연산방향 : →
	5순위 : 비트이동 	<<, >> 			연산방향 : →
	6순위 : 관계 	<, >, <=, >= 		연산방향 : →
	7순위 : 관계 	==, != 			연산방향 : →
	8순위 : 비트 곱 	& 			연산방향 : →
	9순위 : 비트 차 	^ 			연산방향 : →
	10순위 : 비트 합 	 |			연산방향 : →
	11순위 : 논리 곱 	&&			연산방향 : →
	12순위 : 논리 합 	||			연산방향 : →
	13순위 : 조건	?, :			연산방향 : →
	14순위 : 대입 	=, +=, -=, *=, %=, /=	연산방향 : ←

자바 프로그래밍 정리 노트[2022.01.07] - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

📌 조건문 : 주어진 조건에 따라 다른 문장을 선택할 수 있도록 프로그래밍
   ◾ if문 : 주어진 조건식이 '참'일 경우에 중괄호 안에 있는 문장을 수행
	if (조건식) {
	   수행문;		// 조건식이 참일 경우에 문장 수행
          	}

   ◾ if - else문 : 조건식을 만족하는 경우와 만족하지 않는 경우를 모두 나타낼 때 사용
	if (조건식) {
	   수행문1;	// 조건식이 참일 경우에 문장 수행
	}
	else (조건식) {
	   수행문2;	// 조건식이 거짓일 경우에 문장 수행
	}

   ◾ if - else if - else문 : 하나의 상황에 조건이 여러 개인 경우
	if (조건식1) {
	   수행문1;	// 조건식1이 참일 경우에 문장 수행
	}
	else if (조건식2) {
	   수행문2;	// 조건식2가 참일 경우에 문장 수행
	}
	else if (조건식3) {
	   수행문3;	// 조건식3이 참일 경우에 문장 수행
	}
	else {
	   수행문4;	// 위의 조건이 모두 해당하지 않는 경우에 수행
	}
	수행문5;		// if - esle if - else문이 모두 끝난 후 수행

   ◾ if - else문 			   ◾ 조건 연산자
         if (a > b)
	max = a;		→	    max = (a > b) ? a : b;
         else
	max = b;

   ◾ switch - case문 : 조건이 하나의 변수 값이나 상수 값으로 구분되는 경우에 사용함
	switch (조건) {
	   case 값1 : 수행문1;	break;
	   case 값2 : 수행문2;	break;
	   case 값3 : 수행문3;	break;
	default : 수행문4;		// 주어진 값이 어떤 case에도 해당하지 않으면 수행함 -> if - else문의 else와 같은 동작
	}

📌 반복문 : 반복되는 일을 처리
   ◾ while문 : 조건식이 참인 동안 수행문을 반복 수행
	while (조건식) {
	   수행문1;	// 조건식이 참인 동안 반복 수행
	}
	   수행문2;

   ◾ do-while문 : { }안 문장을 무조건 한 번 수행한 후 조건식을 검사, 조건이 만족하는지 여부를 마지막에 검사
	do {
	   수행문1;
	} while (조건식);
	   수행문2;

   ◾ for문 : 변수의 초기화식, 조건식, 증감식을 이용해 반복 수행
	for ( 초기화식; 조건식; 증감식 ) {
	   수행문;
	}

   ◾ continue문 : 반복문을 수행하는데 특정 조건에서는 수행하지 않고 건너뛰어야 할 때 사용

   ◾ break문 : 수행문을 반복하지 않고 반복문을 빠져나옴

자바 프로그래밍 정리 노트[2022.01.10] - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

📌 객체 : 의사나 행위가 미치는 대상
   ◾ 객체 지향 프로그램 : 어떤 대상(객체)을 가지고 프로그래밍함
   ◾ 자바 객체 지향 프로그래밍 (OOP) : 객체를 기반으로 하는 프로그램

📌 절차 지향 프로그래밍 : 순서대로 일어나는 일을 시간순으로 프로그래밍 하는 것
   ◾ C언어

📌 객체 지향 프로그래밍 : 객체를 정의하고 객체 간 협력을 프로그래밍 하는 것
   ◾ 자바

📌 클래스 : 객체의 속성과 기능을 코드로 구현한 것 (클래스 이름은 대문자로 시작함)
   ◾ 멤버 변수 : 클래스 속성(특성이라고도 하고 클래스 내부에 변수로 선언)
	(접근 제어자) class 클래스 이름 {
	   멤버 변수;
	   메서드;
	}

📌 멤버 변수 : 클래스 내부에 선언하여 객체 속성을 나타내는 변수
   ◾ 변수의 자료형
	1) 기본 자료형 : int, long, float, double 등
	2) 참조 자료형 : String, Date, Student 등

📌 멤버 함수(메서드) : 클래스 내부에서 멤버 변수를 사용하여 클래스 기능을 구현한 것

📌 패키지 : 클래스 파일의 묶음

📌 함수 : 하나의 기능을 수행하는 일련의 코드, 어떤 기능을 수행하도록 미리 구현해 놓고 필요할 때 호출해 사용
   ◾ 이름이 있고 입력 값과 결과 값을 가짐
   ◾ 매개변수 : 함수의 입력으로 받는 변수
   ◾ 반환 값 : 함수를 수행한 후 결과로 되돌려 주는 값이 result

   ◾ 함수를 정의한다 : 함수가 하는 일을 코드로 구현
   ◾ 함수를 호출한다 : 함수를 사용하는 것

   ◾ 스택(stack) : 메모리 공간
   ◾ 지역 변수 : 함수 내부에서만 사용하는 변수

📌 main() 함수 : 자바 가상 머신(JVM)이 프로그램을 시작하기 위해 호출하는 함수

📌 new 예약어로 클래스 생성
   ◾ 클래스형 변수 이름 = new 생성자;

   ◾ 인스턴스 : 실제로 사용할 수 있도록 생성된 클래스
   ◾ 참조변수 : 인스턴스를 가리키는 클래스형 변수 (도트(.) 연산자를 사용)
	참조 변수.멤버 변수
	참조 변수.메서드

📌 생성자 : 클래스를 처음 만들 때 멤버 변수나 상수를 초기화
   ◾ 디폴트 생성자 : 자동으로 만들어 주는 생성자

   ◾ 생성자 오버로드 : 클래스에 생성자가 두 개 이상 제공되는 경우

📌 참조 자료형 변수 : 클래스 자료형으로 선언

📌 접근 제어자 : 예약어를 사용해 클래스 내부 변수나 메서드, 생성자에 대한 접근 권한을 지정
   ◾ public : 외부 클래스에서 접근이 가능하며 외부 클래스가 사용할 수 있음
   ◾ private : 외부 클래스에서 사용할 수 없음

📌 get( ), set( ) 메서드 : 다른 변수에 접근할 수 있도록 함

자바 프로그래밍 정리 노트[2022.01.11] - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

📌 this 예약어 : 생성된 인스턴스 자신을 가리킴
   ◾ 생성된 클래스 자신의 주소 값을 반환

📌 static 변수 : 클래스에서 공통으로 사용하는 변수
   ◾ 정적(클래스) 변수 - 클래스 내부에 선언
	static int serialNum;

   ◾ 지역변수 - 메서드가 호출될 때 메모리에 생성되어 메서드가 끝나면 사라짐

📌 변수   
   ◾ 지역 (로컬) 변수	- 함수 내부에 선언				- 스택 메모리
   ◾ 멤버 (인스턴스) 변수	- 클래스 멤버 변수로 선언			- 힙 메모리
   ◾ static (클래스) 변수	- static 예약어를 사용해 클래스 내부에 선언	- 데이터 영역 메모리

📌 배열 : 자료형이 같은 자료 여러 개를 한 번에 관리 할 수 있음
	자료형[ ]   배열 이름 = new   자료형[개수];
	자료형   배열 이름[ ] = new   자료형[개수];

   ◾ 배열 초기화 : 배열을 선언하면서 동시에 각 요소의 값이 초기화됨
   ◾ 인덱스 연산자 [ ] : 배열을 처음 선언할 때 사용한 연산자
   ◾ length 속성 : 배열 길이를 나타냄

📌 향상된 for문 : 배열의 처음에서 끝까지 모든 요소를 참조할 때 사용
	for(변수 : 배열) {
	   반복 실행문;
	}

📌 다차원 배열 : 이차원 이상으로 구현한 배열, 평면이나 공간
	int [ ][ ] arr = new int [2][3];

📌 ArrayList 클래스 : 객체 배열을 관리할 수 있는 멤버 변수와 메서드를 제공
   ◾ boolean add(E e)	- 요소 하나를 배열에 추가
   ◾ int size( )		- 배열에 추가된 요소 전체 개수를 반환
   ◾ E get(int index)		- 배열 index 위치에 있는 요소 값을 반환
   ◾ E remove(int index)	- 배열 index 위치에 있는 요소 값을 제거하고 그 값을 반환
   ◾ boolean isEmpty( )	- 배열이 비어 있는지 확인

📌 임포트(import) : 클래스를 가져와 사용할 때 이 클래스가 어디에 구현되어 있다고 알려주기 위해 코드 맨 위에 선언함

📌 size( ) 메서드 : 배열에 유효한 값이 저장된 요소 개수를 반환

자바 프로그래밍 정리 노트[2022.01.12] - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

📌 상속 : 부모가 자식에게 물려주는 재산
   ◾ 부모 클래스 (parent class) - 상위 클래스
   ◾ 자식 클래스 (child class)	- 하위 클래스

   ◾ extends 예약어 : 상속 구현, A가 가지고 있는 속성이나 기능을 추가로 확장해 B클래스를 구현
	class B extends A {
	}

   ◾ 하위 클래스가 생성될 때는 상위 클래스의 생성자가 먼저 호출됨

   ◾ super 예약어 : 하위 클래스에서 상위 클래스로 접근, 하위 클래스는 상위 클래스의 주소(참조 값)을 알고 있음
   ◾ 디폴트 생성자가 아닌 매개변수가 있는 생성자를 직접 구현
   ◾ 하위 클래스의 인스턴스가 상위 클래스로 형 변환되는 과정이 묵시적으로 이루어짐

   ◾ 메서드 오버라이딩(method overriding) : 상위 클래스에 정의한 메서드가 하위 클래스에서 구현할 내용과 맞지 않을 경우에 하위 클래스에서 이 메서드를 재정의
	오버라이딩을 하려면 반환형, 메서드 이름, 매개 변수 개수, 매개변수 자료형이 반드시 같아야 함

   ◾ @Override 애노테이션 : '이 메서드는 재정의된 메서드입니다'라고 컴파일러에 명확히 알려줌

📌 private : 필요에 따라 멤버 변수나 메서드를 외부에 노출하지 않음

📌 protected : 상위 클래스에 작성한 변수나 메서드 중 외부 클래스에서 사용할 수 없지만 하위 클래스에선 사용할 수 있도록 지정함
  
📌 다형성 : 하나의 코드가 여러 자료형으로 구현되어 실행됨, 추상 클래스, 인터페이스에서 구현

자바 프로그래밍 정리 노트[2022.01.13] - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

📌 추상 클래스 : 추상 메서드를 항상 포함하며 함수의 구현 코드가 없다는 것
   ◾ 추상 메서드 (abstract method) - 함수 몸체(body)가 없다
   ◾ 추상 함수 (abstract function) - { } 함수 몸체가 없는 함수
   ◾ abstract 예약어를 사용하며 { } 대신 ; 를 씀	← 선언만 하는 메서드

   ◾ 추상 클래스는 인스턴스로 생성할 수 없다
	구현된 메서드 - 하위 클래스에서 공통으로 사용할 구현 코드 (하위 클래스에서 재정의 할 수 있음)
	추상 메서드 - 하위 클래스가 어떤 클래스냐에 따라 구현 코드가 달라짐

📌 템플릿 메서드 : 디자인 패턴의 한 방법으로 모든 객체 지향 프로그램에서 사용하는 구현 방법

📌 final 예약어 : 마지막으로 정한 것으로 더 이상 수정 할 수 없음
   ◾ final 변수 - 상수를 의미함	
   ◾ final 메서드 - 하위 클래스에서 재정의 할 수 없음
   ◾ final 클래스 - 상속할 수 없음

📌 인터페이스(interface) : 클래스 혹은 프로그램이 제공하는 기능을 명시적으로 선언함
   ◾ 추상 메서드와 상수로만 이루어짐
   ◾ 인스턴스를 생성할 수 없음

   ◾ implements : 클래스에서 인터페이스를 구현함

   ◾ 인터페이스에 선언한 변수를 컴파일 하면 상수로 변환 됨
   ◾ 형 상속 - 인터페이스 간에도 상속이 가능함

📌 디폴트 메서드 : 기본으로 제공되는 메서드

📌 정적 메서드 : static 예약어를 사용하여 선언해 클래스 생성과 무관하게 사용함

📌 private 메서드 : 인터페이스를 구현한 클래스에서 사용하거나 재정의 할 수 없음

자바 프로그래밍 정리 노트[2022.01.14] - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 


자바 프로그래밍 정리 노트[2022.01.14] - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

